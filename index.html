<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Bitcoin Dashboard</title>
    <!-- ApexCharts CDN -->
    <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
    <style>
        /* Universal Box Sizing & Base Styles */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #000000;
            color: #e0e0e0;
            margin: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden; /* Prevent scrollbars on the body */
        }

        /* Main Layout Container */
        .app-layout {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
        }

        /* Header Section */
        .ticker-header {
            flex-shrink: 0; /* Prevent header from shrinking */
            height: 95px; /* Fixed height */
            background-color: #1a1a1a;
            padding: 10px 25px;
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .left-group {
            display: flex;
            align-items: center;
            gap: 15px; /* Space between logo and title */
        }

        #bitcoin-logo-svg {
            height: 40px;
            width: auto;
            vertical-align: middle;
        }

        .left-group h1 {
            color: #ffffff;
            font-size: 1.4em;
            font-weight: 500;
        }

        .right-group {
            text-align: right;
        }

        #price {
            font-size: 3.2em;
            font-weight: 700;
            color: #00aaff; /* Distinct blue color */
            line-height: 1.1;
            min-height: 45px; /* Reserve space */
        }
        #price.loading, #price.error {
             font-size: 1.8em; /* Smaller font for messages */
             font-weight: 400;
             color: #888; /* Gray for loading/error */
             line-height: 2.5;
        }
        #price.error {
            color: #ef5350; /* Red for error */
        }


        .price-stats {
            font-size: 0.95em;
            color: #b0b0b0;
            margin-top: 5px;
            min-height: 1.2em;
        }

        .price-stats span {
            margin-left: 15px; /* Spacing between stats */
        }
        .price-stats span:first-child {
            margin-left: 0;
        }


        #change-24h {
            font-weight: 600;
        }

        #change-24h.positive {
            color: #26a69a; /* Green */
        }

        #change-24h.negative {
            color: #ef5350; /* Red */
        }

        #change-24h.neutral {
            color: #b0b0b0; /* Gray */
        }

        .source {
            font-size: 0.75em;
            color: #888;
            margin-top: 4px;
        }

        /* Chart Container */
        #chart-container {
            flex-grow: 1; /* Take remaining vertical space */
            background-color: #000000;
            padding: 5px; /* Minimal padding around chart */
            position: relative; /* For absolute positioning of overlays */
            overflow: hidden; /* Ensure chart doesn't overflow */
            min-height: 200px; /* Minimum height */
        }

        #chart-status {
            position: absolute;
            top: 15px;
            left: 15px;
            background-color: rgba(40, 40, 40, 0.85);
            color: #e0e0e0;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.9em;
            z-index: 10;
            display: none; /* Hidden by default */
            transition: opacity 0.3s ease;
        }
         #chart-status.error {
             background-color: rgba(239, 83, 80, 0.85); /* Red background for errors */
             color: #fff;
         }
         #chart-status.success {
             background-color: rgba(38, 166, 154, 0.85); /* Green background for success */
              color: #fff;
         }

        #chart-timeframe {
            position: absolute;
            bottom: 10px;
            right: 15px;
            background-color: rgba(40, 40, 40, 0.7);
            color: #aaa;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            z-index: 5;
        }

        /* Ticker Tape Styles (Common) */
        .ticker-tape {
            flex-shrink: 0; /* Prevent tickers from shrinking */
            width: 100%;
            background-color: #1a1a1a;
            padding: 10px 0; /* Adjusted padding */
            overflow: hidden;
            white-space: nowrap;
            border-top: 1px solid #333;
            font-size: 1.1em; /* Slightly larger font */
        }

        .ticker-tape .content {
            display: inline-block;
            padding-left: 100%; /* Start off-screen */
            animation: scroll-left 45s linear infinite;
        }

        .ticker-tape:hover .content {
            animation-play-state: paused;
        }

        /* Keyframes for Scrolling Animation */
        @keyframes scroll-left {
            0% {
                transform: translateX(0%);
            }
            100% {
                transform: translateX(-100%); /* Scroll entire content width */
            }
        }

        /* Crypto Ticker Specific Styles */
        #crypto-ticker-tape {
            color: #cccccc;
        }
        #crypto-ticker-content span {
            margin-right: 35px; /* Space between crypto items */
        }
         #crypto-ticker-content span .ticker-pair {
             font-weight: 500;
             color: #e0e0e0;
         }
         #crypto-ticker-content span .ticker-price {
             color: #00aaff; /* Blue price */
             margin-left: 8px;
         }
         #crypto-ticker-content span .error {
            color: #ef5350;
            font-style: italic;
         }

    </style>
</head>
<body>
    <div class="app-layout">
        <!-- Header -->
        <header class="ticker-header">
            <div class="left-group">
                <img id="bitcoin-logo-svg" alt="Bitcoin Logo" src='data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNTU2cHgiIGhlaWdodD0iNzZweCIgdmlld0JveD0iMCAwIDU1NiA3NiIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj4KICAgIDx0aXRsZT5sb2dvLWJpdGNvaW4tZXBzPC90aXRsZT4KICAgIDxnIGlkPSJsb2dvLWJpdGNvaW4tZXBzIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8cGF0aCBkPSJNNTA3LjM2Niw2MS40NjkgTDUzOS4xMSw2MS40NjkgTDUzOS4xMSw1NC4wMjcgTDUxNS41NzksNTQuMDI3IEw1MTUuNTc5LDQxLjQ5MiBMNTM2Ljc1OSw0MS40OTIgTDUzNi43NTksMzQuMDUgTDUxNS41NzksMzQuMDUgTDUxNS41NzksMjIuNjkgTDUzNy45MzQsMjIuNjkgTDUzNy45MzQsMTUuMjQ5IEw1MDcuMzY2LDE1LjI0OSBMNTA3LjM2Niw2MS40NzEgTDUwNy4zNjYsNjEuNDY5IFogTTQ5Ny42NTMsMzQuNDQyIEw0NzkuOTg5LDM0LjQ0MiBMNDc5Ljk4OSw0MS44ODQgTDQ4OS40NDEsNDEuODg0IEw0ODkuNDQxLDUyLjc4NyBDNDg3LjkwOCw1My42NTMgNDg2LjI0Nyw1NC4yNyA0ODQuNTIxLDU0LjYxNSBDNDgyLjU4MSw1NS4wMTcgNDgwLjYwMyw1NS4yMTQgNDc4LjYyMiw1NS4yMDMgQzQ3Ni4zOTIsNTUuMjM2IDQ3NC4xODIsNTQuNzkxIDQ3Mi4xMzksNTMuODk4IEM0NzAuMjQ1LDUzLjA1OCA0NjguNTQ3LDUxLjgzNSA0NjcuMTQ5LDUwLjMwNyBDNDY1LjcyOCw0OC43MzEgNDY0LjYzNCw0Ni44ODkgNDYzLjkyNiw0NC44ODkgQzQ2My4xNDUsNDIuNjg5IDQ2Mi43NTgsNDAuMzY4IDQ2Mi43ODIsMzguMDM0IEM0NjIuNzY2LDM1LjgyOCA0NjMuMTUyLDMzLjYzNyA0NjMuOTI2LDMxLjU3IEM0NjQuNjUsMjkuNjI3IDQ2NS43NDUsMjcuODQyIDQ2Ny4xNDksMjYuMzE2IEM0NjguNTUsMjQuODA3IDQ3MC4yNDksMjMuNjA3IDQ3Mi4xMzksMjIuNzkxIEM0NzQuMTg3LDIxLjkxOCA0NzYuMzk1LDIxLjQ4NSA0NzguNjIyLDIxLjUxNyBDNDgwLjkwMSwyMS41MDYgNDgzLjE2NCwyMS45MDMgNDg1LjMwMywyMi42OTIgQzQ4Ny4zMDksMjMuNDEzIDQ4OS4xNDEsMjQuNTQ4IDQ5MC42ODEsMjYuMDIyIEw0OTYuNzQ0LDE5Ljg4NSBDNDk0LjM3NiwxNy43NDcgNDkxLjU0LDE2LjE5MyA0ODguNDYzLDE1LjM0OCBDNDg1LjIzMywxNC40ODEgNDgxLjkwMiwxNC4wNTIgNDc4LjU1OSwxNC4wNzUgQzQ3NS4yMSwxNC4wMzcgNDcxLjg4NCwxNC42MjQgNDY4Ljc1LDE1LjgwNSBDNDY1Ljg3MSwxNi44OTUgNDYzLjI1MiwxOC41NzQgNDYxLjA1OSwyMC43MzQgQzQ1OC44NiwyMi45MzggNDU3LjE0LDI1LjU3MSA0NTYuMDA2LDI4LjQ3IEM0NTQuNzU0LDMxLjY4MyA0NTQuMTM1LDM1LjEwOCA0NTQuMTgyLDM4LjU1NiBDNDU0LjEzNiw0MS45MyA0NTQuNzU2LDQ1LjI3OSA0NTYuMDA2LDQ4LjQxNCBDNDU4LjI5OSw1NC4xOTQgNDYyLjkyOCw1OC43MzQgNDY4Ljc1LDYwLjkxMyBDNDcxLjg4NCw2Mi4wOTUgNDc1LjIxLDYyLjY4MiA0NzguNTU5LDYyLjY0NCBDNDg1LjIwNSw2Mi43MzggNDkxLjc3LDYxLjE2NyA0OTcuNjU0LDU4LjA3MyBMNDk3LjY1NCwzNC40NDIgTDQ5Ny42NTMsMzQuNDQyIFogTTQwNC43NzgsNjEuNDY5IEw0MTIuOTksNjEuNDY5IEw0MTIuOTksMjYuMDIgTDQxMy4xMTgsMjYuMDIgTDQzNS45MzIsNjEuNDY5IEw0NDYuMzYyLDYxLjQ2OSBMNDQ2LjM2MiwxNS4yNDcgTDQzOC4xNDksMTUuMjQ3IEw0MzguMTQ5LDQ5LjU4NSBMNDM4LjAxNyw0OS41ODUgTDQxNS42NjEsMTUuMjQ3IEw0MDQuNzc4LDE1LjI0NyBMNDA0Ljc3OCw2MS40NjkgWiBNMzY4LjczMSw0My44NDIgTDM3NS45NzEsMjUuMDQxIEwzODMuMDcxLDQzLjg0MiBMMzY4LjczMSw0My44NDIgWiBNMzUyLjU3Miw2MS40NjkgTDM2MS43NTgsNjEuNDY5IEwzNjUuOTM0LDUwLjg5MyBMMzg1LjkzOCw1MC44OTMgTDM5MC4yNDEsNjEuNDY5IEwzOTkuNjI5LDYxLjQ2OSBMMzc5Ljc0NywxNS4yNDcgTDM3Mi42NDUsMTUuMjQ3IEwzNTIuNTcyLDYxLjQ2OSBaIE0zMDkuNDI0LDYxLjQ2OSBMMzE3LjYzNyw2MS40NjkgTDMxNy42MzcsNDEuMTAxIEwzMzkuMjEsNDEuMTAxIEwzMzkuMjEsNjEuNDY5IEwzNDcuNDE4LDYxLjQ2OSBMMzQ3LjQxOCwxNS4yNDcgTDMzOS4yMSwxNS4yNDcgTDMzOS4yMSwzMy42NTYgTDMxNy42MzcsMzMuNjU2IEwzMTcuNjM3LDE1LjI0OSBMMzA5LjQyNCwxNS4yNDkgTDMwOS40MjQsNjEuNDcxIEwzMDkuNDI0LDYxLjQ2OSBaIE0zMDIuODM5LDIxLjM4NSBDMzAwLjgyNCwxOC45NDggMjk4LjI2OSwxNy4wMTQgMjk1LjM3NiwxNS43MzggQzI5Mi42MTQsMTQuNjExIDI4OS42NTYsMTQuMDQ2IDI4Ni42NzUsMTQuMDc0IEMyODMuMzI2LDE0LjAzNSAyODAsMTQuNjIyIDI3Ni44NjYsMTUuODAzIEMyNzMuOTg3LDE2Ljg5MyAyNzEuMzY4LDE4LjU3MiAyNjkuMTc1LDIwLjczMyBDMjY2Ljk3NiwyMi45MzYgMjY1LjI1NiwyNS41NjkgMjY0LjEyMSwyOC40NjggQzI2Mi44NywzMS42ODIgMjYyLjI1LDM1LjEwNyAyNjIuMjk3LDM4LjU1NCBDMjYyLjI1MSw0MS45MjkgMjYyLjg3MSw0NS4yNzggMjY0LjEyMSw0OC40MTIgQzI2Ni40MTQsNTQuMTkyIDI3MS4wNDMsNTguNzMyIDI3Ni44NjYsNjAuOTEyIEMyNzkuOTk5LDYyLjA5NCAyODMuMzI2LDYyLjY4MSAyODYuNjc1LDYyLjY0MyBDMjg5Ljk2OSw2Mi42NjEgMjkzLjIzMSw2MS45OTQgMjk2LjI1NCw2MC42ODQgQzI5OS4zMTgsNTkuMzI1IDMwMS45NTUsNTcuMTU5IDMwMy44ODIsNTQuNDE2IEwyOTcuMTA1LDQ5LjU4NiBDMjk1LjgsNTEuMzU5IDI5NC4xMTgsNTIuODE5IDI5Mi4xOCw1My44NjEgQzI5MC40OTgsNTQuNzM2IDI4OC4zMzMsNTUuMTk0IDI4Ni43MzgsNTUuMiBDMjg0LjUwOSw1NS4yMzMgMjgyLjI5OCw1NC43ODcgMjgwLjI1NCw1My44OTQgQzI3OC4zNjIsNTMuMDU2IDI3Ni42NjUsNTEuODMzIDI3NS4yNyw1MC4zMDQgQzI3My44NDcsNDguNzI5IDI3Mi43NDksNDYuODg3IDI3Mi4wNDIsNDQuODg1IEMyNzEuMjYzLDQyLjY4NSAyNzAuODc4LDQwLjM2NCAyNzAuOTAzLDM4LjAzIEMyNzAuODg1LDM1LjgyNSAyNzEuMjcsMzMuNjM0IDI3Mi4wNDIsMzEuNTY4IEMyNzIuNzY3LDI5LjYyMyAyNzMuODYzLDI3LjgzOCAyNzUuMjcsMjYuMzEyIEMyNzYuNjY4LDI0LjgwMyAyNzguMzY2LDIzLjYwMyAyODAuMjU0LDIyLjc4NyBDMjgyLjMwMywyMS45MTUgMjg0LjUxMiwyMS40ODIgMjg2LjczOCwyMS41MTQgQzI4OC4zNzksMjEuNTIgMjkwLjAwMywyMS44MyAyOTEuNTMsMjIuNDI4IEMyOTMuMTE1LDIzLjAzOCAyOTQuNzU2LDI0LjI1NyAyOTYuNDUxLDI2LjA4NCBMMzAyLjgzOSwyMS4zODUgWiBNMjQ4Ljg3NywwLjAyMSBMNTU1LjM5NywwLjAyMSBDNTU1LjUxNSwwLjAyMSA1NTUuNjA5LDAuMTE2IDU1NS42MDksMC4yMzQgTDU1NS42MDksNzUuNzg3IEM1NTUuNjA5LDc1LjkwNCA1NTUuNTE1LDc2IDU1NS4zOTcsNzYgTDI0OC44NzcsNzYgQzI0OC43Niw3NiAyNDguNjY0LDc1LjkwNCAyNDguNjY0LDc1Ljc4NyBMMjQ4LjY2NCwwLjIzNCBDMjQ4LjY2NCwwLjExNiAyNDguNzYsMC4wMjEgMjQ4Ljg3NywwLjAyMSBMMjQ4Ljg3NywwLjAyMSBaIiBpZD0iRmlsbC0xIiBmaWxsPSIjRjNCNDI5Ij48L3BhdGg+CiAgICAgICAgPHBhdGggZD0iTTE5Ny41OCwyOS45MzEgQzE5Ny41OCwyOC4zMzYgMTk4LjQ1MywyNy41MzggMTk5Ljk3NCwyNy41MzggTDIwMi4wMDYsMjcuNTM4IEMyMDMuNjAyLDI3LjUzOCAyMDQuNCwyOC4zMzYgMjA0LjQsMjkuOTMxIEwyMDQuNCwzMy4xOTUgQzIwNC4zOTIsMzMuOTAyIDIwNC4zMTksMzQuNjA2IDIwNC4xODIsMzUuMjk5IEwyMDQuMzI1LDM1LjI5OSBDMjA2Ljg5MiwyOS45NTUgMjEyLjMyOCwyNi41ODcgMjE4LjI1NiwyNi42NjcgQzIyNi44ODksMjYuNjY3IDIzMC44MDMsMzEuMzgyIDIzMC44MDMsNDAuNzM5IEwyMzAuODAzLDYxLjg0OSBDMjMwLjgwMyw2My40NDQgMjMwLjAwNSw2NC4yNDIgMjI4LjQxLDY0LjI0MiBMMjI2LjE2NSw2NC4yNDIgQzIyNC42MzksNjQuMjQyIDIyMy43NjYsNjMuNDQ0IDIyMy43NjYsNjEuODQ5IEwyMjMuNzY2LDQyLjMzNSBDMjIzLjc2NiwzNy4xODUgMjIyLjc1LDMzLjEyMyAyMTYuODc4LDMzLjEyMyBDMjA5Ljc2NywzMy4xMjMgMjA0LjYxOCwzOS4wNzEgMjA0LjYxOCw0Ni42ODcgTDIwNC42MTgsNjEuODQ2IEMyMDQuNjE4LDYzLjQ0MiAyMDMuODIsNjQuMjM5IDIwMi4yMjQsNjQuMjM5IEwxOTkuOTc0LDY0LjIzOSBDMTk4LjQ1Myw2NC4yMzkgMTk3LjU4LDYzLjQ0MiAxOTcuNTgsNjEuODQ2IEwxOTcuNTgsMjkuOTMxIFogTTE4MC4zOSwyOS45MzEgQzE4MC4zOSwyOC4zMzYgMTgxLjI1NywyNy41MzggMTgyLjc4MywyNy41MzggTDE4NS4wMjgsMjcuNTM4IEMxODYuNjI5LDI3LjUzOCAxODcuNDI5LDI4LjMzNiAxODcuNDI3MDA0LDI5LjkzMSBMMTg3LjQyNzAwNCw2MS44NDkgQzE4Ny40MjcwMDQsNjMuNDQ0IDE4Ni42MjcsNjQuMjQyIDE4NS4wMjgsNjQuMjQyIEwxODIuNzgzLDY0LjI0MiBDMTgxLjI1Nyw2NC4yNDIgMTgwLjM5LDYzLjQ0NCAxODAuMzksNjEuODQ5IEwxODAuMzksMjkuOTMxIFogTTE4MC4zMTUsMTcuODE3IEwxODAuMzE1LDE1LjQyMyBDMTgwLjMxNSwxMy44MjcgMTgxLjExMywxMy4wMjkgMTgyLjcwOCwxMy4wMjkgTDE4NS4xNzcsMTMuMDI5IEMxODYuNjk4LDEzLjAyOSAxODcuNTcsMTMuODI3IDE4Ny41NywxNS40MjMgTDE4Ny41NywxNy44MTcgQzE4Ny41NywxOS4zNCAxODYuNjk4LDIwLjIxMDAwMDkgMTg1LjE3NywyMC4yMTAwMDA5IEwxODIuNzA4LDIwLjIxMDAwMDkgQzE4MS4xMTMsMjAuMjExIDE4MC4zMTUsMTkuMzM5IDE4MC4zMTUsMTcuODE3IFogTTE1Mi44MjEsNTkuMDIgQzE1OS43ODksNTkuMDIgMTY1LjQ0Myw1My41MDYgMTY1LjQ0Myw0NS44MTggQzE2NS40NDMsMzguMjAxIDE1OS43ODksMzIuNzYgMTUyLjgyMSwzMi43NiBDMTQ1LjkzMywzMi43NiAxNDAuMTk5LDM4LjIwMSAxNDAuMTk5LDQ1LjgxOCBDMTQwLjE5OSw1My41MDYgMTQ1LjkzMyw1OS4wMTkgMTUyLjgyMSw1OS4wMTkgTDE1Mi44MjEsNTkuMDIgWiBNMTUyLjgyMSwyNi42NjcgQzE2My43NzgsMjYuNjY3IDE3Mi42MjksMzQuNzE5IDE3Mi42MjksNDUuODE2IEMxNzIuNjI5LDU2Ljk4NiAxNjMuNzc4LDY1LjExMSAxNTIuODIxLDY1LjExMSBDMTQxLjg2NCw2NS4xMTEgMTMzLjA5Myw1Ni45ODcgMTMzLjA5Myw0NS44MTYgQzEzMy4wOTMsMzQuNzE5IDE0MS44NjksMjYuNjY3IDE1Mi44MjEsMjYuNjY3IFogTTExNC41OTMsMjYuNjY3IEMxMjAuNzU4LDI2LjY2NyAxMjQuNzQ3LDI5LjA2MSAxMjYuNzEsMzAuNTg0IEMxMjcuOTM5LDMxLjM4MiAxMjguMDEzLDMyLjYxNSAxMjcuMTQxLDMzLjg0OCBMMTI2LjQxNywzNC45MzcgQzEyNS41NDUsMzYuMjQyIDEyNC41MjksMzYuMzE1IDEyMy4xNTEsMzUuNTE3IEMxMjAuNzc3LDMzLjc1OSAxMTcuOTA5LDMyLjc5NCAxMTQuOTU1LDMyLjc2IEMxMDcuNTU2LDMyLjc2IDEwMi4xODksMzguMjczIDEwMi4xODksNDUuODE4IEMxMDIuMTg5LDUzLjI4OSAxMDcuNTU2LDU5LjAyIDExNS4wOTksNTkuMDIgQzExOC41MDEsNTguOTY2IDEyMS43OTEsNTcuNzkzIDEyNC40Niw1NS42ODMgQzEyNS43NjMsNTQuODEzIDEyNi44NTMsNTQuOTU3IDEyNy43MjYsNTYuMzM1IEwxMjguMzA2LDU3LjQyNCBDMTI5LjAyOSw1OC42NTYgMTI4LjgxMSw1OS44MTggMTI3LjY1MSw2MC42MTUgQzEyMy45NSw2My41OCAxMTkuMzM1LDY1LjE3IDExNC41OTMsNjUuMTEzIEMxMDMuMDU2LDY1LjExMyA5NS4wMDksNTYuOTE2IDk1LjAwOSw0NS44OSBDOTUuMDA4LDM1LjAwOSAxMDMuMTMxLDI2LjY2NyAxMTQuNTkzLDI2LjY2NyBaIE03NC42OTUsMzMuNjMgTDcyLjE1MywzMy42MyBDNzAuNjMxLDMzLjYzIDY5LjgzMywzMi43NiA2OS44MzMsMzEuMjM2IEw2OS44MzMsMzAuMjk2IEM2OS44MzMsMjguNzczIDcwLjYzMSwyNy45MDMgNzIuMjI3LDI3LjkwMyBMNzQuODM5LDI3LjkwMyBMNzQuODM5LDE5Ljg0OCBDNzQuODM5LDE4LjI1MyA3NS43MTEsMTcuNDU0IDc3LjIzMiwxNy40NTQgTDc5LjMzOSwxNy40NTQgQzgwLjkzNCwxNy40NTQgODEuNzMyLDE4LjI1MyA4MS43MzIsMTkuODQ4IEw4MS43MzIsMjcuOTAzIEw4OC4xMTUsMjcuOTAzIEM4OS43MTEsMjcuOTAzIDkwLjUwOSwyOC43NzMgOTAuNTA5LDMwLjI5NiBMOTAuNTA5LDMxLjI0IEM5MC41MDksMzIuNzYzIDg5LjcxMSwzMy42MzMgODguMTg5LDMzLjYzMyBMODEuNzMyLDMzLjYzMyBMODEuNzMyLDQ5Ljk1NSBDODEuNzMyLDU2LjkxOSA4Ni4wMDksNTguMDA3IDg4LjY5NSw1OC4yMjUgQzkwLjU4Myw1OC4zNyA5MS4yMzIsNTguOTQ5IDkxLjIzMiw2MC42MTggTDkxLjIzMiw2Mi4xNDIgQzkxLjIzMiw2My44MTEgOTAuMjksNjQuNTM1IDg4LjMzMyw2NC41MzUgQzgxLjA3OCw2NC41MzUgNzQuNjk1LDYwLjMyOCA3NC42OTUsNTEuMDQzIEw3NC42OTUsMzMuNjMgWiBNNTUuNzU5LDI5LjkzMSBDNTUuNzU5LDI4LjMzNiA1Ni42MzIsMjcuNTM4IDU4LjE1MywyNy41MzggTDYwLjQwMywyNy41MzggQzYxLjk5OCwyNy41MzggNjIuNzk2LDI4LjMzNiA2Mi43OTYsMjkuOTMxIEw2Mi43OTYsNjEuODQ5IEM2Mi43OTYsNjMuNDQ0IDYxLjk5OCw2NC4yNDIgNjAuNDAzLDY0LjI0MiBMNTguMTUzLDY0LjI0MiBDNTYuNjMyLDY0LjI0MiA1NS43NTksNjMuNDQ0IDU1Ljc1OSw2MS44NDkgTDU1Ljc1OSwyOS45MzEgWiBNNTUuNjksMTcuODE3IEw1NS42OSwxNS40MjMgQzU1LjY5LDEzLjgyNyA1Ni40ODMsMTMuMDI5IDU4LjA4NCwxMy4wMjkgTDYwLjU0NiwxMy4wMjkgQzYyLjA3MywxMy4wMjkgNjIuOTQsMTMuODI3IDYyLjk0LDE1LjQyMyBMNjIuOTQsMTcuODE3IEM2Mi45NCwxOS4zNCA2Mi4wNzMsMjAuMjEwMDAwOSA2MC41NDYsMjAuMjEwMDAwOSBMNTguMDg0LDIwLjIxMDAwMDkgQzU2LjQ4MywyMC4yMTEgNTUuNjksMTkuMzM5IDU1LjY5LDE3LjgxNyBaIE0zMi43MzMsNTcuOTYzIEMzMS4yNTIsNTguNDk2IDI5LjY4NSw1OC43NDUgMjguMTExLDU4LjY5NiBMMTIuNzM0LDU4LjY4OSBMMTIuNzM0LDQwLjcyNiBMMjguNjk2LDQwLjcyMSBDMzQuMTI3LDQwLjcyMSAzNy42NDgsNDQuMjQyIDM3LjY0OCw0OS41OTkgQzM3LjY0OCw1My40ODcgMzUuNzM5LDU2LjcxNiAzMi43MzMsNTcuOTYzIFogTTI2Ljg2MSwxOC45MjkgQzI5LjA2MywxOC45MjkgMzAuNzQ5LDE5LjIyMyAzMi4yMTcsMTkuOTU3IEMzNC40MTksMjEuMjA0IDM1LjU5NSwyMy43NzIgMzUuNTk1LDI2Ljc4IEMzNS41OTUsMzEuNDc2IDMyLjY1OSwzNC43MDYgMjcuOTYyLDM0LjcwNiBMMTIuNzM0LDM0LjcwNiBMMTIuNzM0LDE4LjkyOSBMMjYuODYxLDE4LjkyOSBaIE0zNi41NDcsMzcuNDE5IEwzNi41NDcsMzcuMjcyIEM0MC41ODQsMzUuMjE4IDQzLjA3OSwzMS4xODIgNDMuMDc5LDI2LjEyIEM0My4wNzksMjAuNTQ0IDQwLjA2OCwxNi4yODggMzUuOTYyLDE0LjQ1NCBDMzMuMzkzLDEzLjI4IDMwLjYwNiwxMi45MTEgMjYuODYxLDEyLjkxMSBMMjQuOTMsMTIuOTExIEwyNC45Myw4LjY3NSBDMjQuOTMsNy44NDQgMjQuMjU2LDcuMTcgMjMuNDI1LDcuMTcgTDE5LjA5NSw3LjE3IEMxOC4yNjQsNy4xNyAxNy41OTEsNy44NDQgMTcuNTksOC42NzUgTDE3LjU5LDEyLjkxMSBMMTIuNzM0LDEyLjkxMSBMMTIuNzM0LDguNjc1IEMxMi4zMzMsNy44NDQgMTIuMDYsNy4xNyAxMS4yMjgsNy4xNyBMNi44OTksNy4xNyBDNi4wNjgsNy4xNyA1LjM5NCw3Ljg0NCA1LjM5Myw4LjY3NSBMNS4zOTMsMTIuOTExIEwwLjk2MywxMi45MTEgQzAuNDQxLDEyLjkxMSAwLjAxNywxMy4zMzQgMC4wMTYsMTMuODU2IEwwLjAxNiwxNy45ODMgQzAuMDE3LDE4LjUwNiAwLjQ0MSwxOC45MjggMC45NjMsMTguOTI4IEw1LjM5MywxOC45MjggTDUuMzkzLDU4LjY4MyBMMS4yMTMsNTguNjgzIEMwLjU0Myw1OC42ODMgMCw1OS4yMjYgMCw1OS44OTYgTDAuMDExLDYzLjUwOCBDMC4wMTQsNjQuMTc1IDAuNTU2LDY0LjcxNCAxLjIyNCw2NC43MTQgTDUuMzkzLDY0LjcxNCBMNS4zOTMsNjguODg5IEM1LjM5NCw2OS43MiA2LjA2OCw3MC4zOTMgNi44OTksNzAuMzk0IEwxMS4yMjgsNzAuMzk0IEMxMi4wNiw3MC4zOTMgMTIuNzMzLDY5LjcyIDEyLjczNCw2OC44ODkgTDEyLjczNCw2NC43MTQgTDE3LjU5LDY0LjcxNCBMMTcuNTksNjguODg5IEMxNy41OTEsNjkuNzIgMTguMjY0LDcwLjM5MyAxOS4wOTUsNzAuMzk0IEwyMy40MjUsNzAuMzk0IEMyNC4yNTYsNzAuMzkzIDI0LjkzLDY5LjcyIDI0LjkzLDY4Ljg4OSBMMjQuOTMsNjQuNzE0IEwyNy44MTMsNjQuNzE0IEMzMC42NzUsNjQuNzE0IDMzLjEsNjQuNTY3IDM1LjU5NSw2My43NiBDNDAuOTUxLDYxLjkyNSA0NS4xMzIsNTYuNzg5IDQ1LjEzMiw0OS45NjYgQzQ1LjEzMiw0NC4wOTYgNDIuMTIxLDM5LjAzMyAzNi41NDcsMzcuNDE5IEwzNi41NDcsMzcuNDE5IFoiIGlkPSJGaWxsLTMiIGZpbGw9IiNGM0I0MjkiPjwvcGF0aD4KICAgIDwvZz4KPC9zdmc+'>
                <h1>Bitcoin Live Dashboard</h1>
            </div>
            <div class="right-group">
                <div id="price" class="loading">Loading...</div>
                <div class="price-stats">
                    <span id="change-24h">---%</span>
                    <span>H: <span id="high-24h">---</span></span>
                    <span>L: <span id="low-24h">---</span></span>
                </div>
                 <div class="source">Data from Kraken API</div>
            </div>
        </header>

        <!-- Chart Area -->
        <main id="chart-container">
             <div id="chart-status"></div>
             <div id="chart-timeframe">1-Minute Chart</div>
             <!-- ApexChart will render here -->
        </main>

        <!-- Crypto Ticker Tape -->
        <div id="crypto-ticker-tape" class="ticker-tape">
            <div id="crypto-ticker-content" class="content">
                <span>Loading crypto prices...</span>
            </div>
        </div>

        <!-- Hebrew Ticker Tape Removed -->
        <!--
        <div class="ticker-tape hebrew-ticker">
            <div class="content">
                 ...
            </div>
        </div>
        -->
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Element References ---
            const priceEl = document.getElementById('price');
            const change24hEl = document.getElementById('change-24h');
            const high24hEl = document.getElementById('high-24h');
            const low24hEl = document.getElementById('low-24h');
            const chartContainer = document.getElementById('chart-container');
            const chartStatusEl = document.getElementById('chart-status');
            const chartTimeframeEl = document.getElementById('chart-timeframe');
            const cryptoTickerContentEl = document.getElementById('crypto-ticker-content');

            // --- Constants and State ---
            const KRAKEN_API_BASE = 'https://api.kraken.com/0/public';
            const BTC_PAIR = 'XBTUSDT'; // Kraken uses XBT for Bitcoin
            const OTHER_CRYPTO_PAIRS = 'ETHUSDT,SOLUSDT,ADAUSDT,XRPUSDT';
            const PRICE_UPDATE_INTERVAL = 5000; // 5 seconds
            const CHART_UPDATE_INTERVAL = 60000; // 60 seconds (1 minute)
            const TICKER_UPDATE_INTERVAL = 20000; // 20 seconds
            const CHART_INTERVAL = 1; // 1 minute OHLC data

            let chart = null;
            let fullChartDataOHLC = []; // Stores {x: ts, y: [o,h,l,c]}
            let lastOHLCTimestamp = null; // For fetching incremental updates
            let priceIntervalId = null;
            let chartIntervalId = null;
            let tickerIntervalId = null;
            let chartStatusTimeoutId = null;

            // --- Utility Functions ---

            /**
             * Formats a number using toLocaleString with specified decimal places.
             * Gracefully handles non-numeric input.
             */
            function formatNumber(num, minDecimals = 2, maxDecimals = 2) {
                const number = parseFloat(num);
                if (isNaN(number)) {
                    return '---';
                }
                try {
                    return number.toLocaleString('en-US', {
                        minimumFractionDigits: minDecimals,
                        maximumFractionDigits: maxDecimals,
                    });
                } catch (e) {
                    console.error("Error formatting number:", num, e);
                    return '---';
                }
            }

             /**
             * Formats a number as currency (USD).
             */
            function formatCurrency(num) {
                 const number = parseFloat(num);
                if (isNaN(number)) {
                    return '$---';
                }
                 try {
                    return number.toLocaleString('en-US', {
                        style: 'currency',
                        currency: 'USD',
                        minimumFractionDigits: 2,
                        maximumFractionDigits: 2,
                    });
                 } catch (e) {
                     console.error("Error formatting currency:", num, e);
                     return '$---';
                 }
            }

            /**
             * Shows a status message in the chart overlay.
             * type: 'info' (default), 'error', 'success'
             */
            function showChartStatus(message, type = 'info', duration = 3000) {
                if (!chartStatusEl) return;
                clearTimeout(chartStatusTimeoutId); // Clear previous timeout if any

                chartStatusEl.textContent = message;
                chartStatusEl.className = ''; // Reset classes
                chartStatusEl.classList.add(type); // Add type class (info, error, success)
                chartStatusEl.style.display = 'block';
                chartStatusEl.style.opacity = 1;


                if (duration > 0) {
                    chartStatusTimeoutId = setTimeout(() => {
                        chartStatusEl.style.opacity = 0;
                        // Use transitionend event for smoother hiding, or simple timeout for guaranteed hiding
                         setTimeout(() => { chartStatusEl.style.display = 'none'; }, 300); // Hide after fade out
                    }, duration);
                }
            }

            function hideChartStatus() {
                 if (!chartStatusEl) return;
                 clearTimeout(chartStatusTimeoutId);
                 chartStatusEl.style.opacity = 0;
                 setTimeout(() => { chartStatusEl.style.display = 'none'; }, 300);
            }


            // --- Indicator Calculations ---

            /** Calculates Simple Moving Average (SMA) */
            function calculateSMA(data, period) {
                if (!data || data.length < period) return [];
                const sma = [];
                // Pad beginning with nulls
                for (let i = 0; i < period - 1; i++) {
                    sma.push({ x: data[i].x, y: null });
                }
                // Calculate SMA
                let sum = 0;
                for (let i = 0; i < period; i++) {
                     // Use close price (y[3]) for SMA calculation from OHLC
                    sum += data[i].y[3];
                }
                sma.push({ x: data[period - 1].x, y: sum / period });

                for (let i = period; i < data.length; i++) {
                    sum -= data[i - period].y[3];
                    sum += data[i].y[3];
                    sma.push({ x: data[i].x, y: sum / period });
                }
                return sma;
            }

            /** Calculates Standard Deviation (needed for Bollinger Bands) */
            function calculateStandardDeviation(dataSlice) {
                const n = dataSlice.length;
                if (n === 0) return 0;
                 // Use close price (y[3] or simple y if area data)
                const mean = dataSlice.reduce((acc, val) => acc + (val.y[3] !== undefined ? val.y[3] : val.y), 0) / n;
                const variance = dataSlice.reduce((acc, val) => acc + Math.pow((val.y[3] !== undefined ? val.y[3] : val.y) - mean, 2), 0) / n;
                return Math.sqrt(variance);
            }

            /** Calculates Bollinger Bands */
             function calculateBollingerBands(data, period, stdDevMultiplier) {
                if (!data || data.length < period) return { upper: [], middle: [], lower: [] };

                const middle = calculateSMA(data, period); // Middle Band is just SMA
                const upper = [];
                const lower = [];

                for(let i = 0; i < period - 1; i++) {
                    upper.push({ x: data[i].x, y: null });
                    lower.push({ x: data[i].x, y: null });
                }


                for (let i = period - 1; i < data.length; i++) {
                    const slice = data.slice(i - period + 1, i + 1);
                    const stdDev = calculateStandardDeviation(slice);
                    const middleValue = middle[i].y; // Get corresponding SMA value

                    if (middleValue !== null) {
                         upper.push({ x: data[i].x, y: middleValue + stdDev * stdDevMultiplier });
                         lower.push({ x: data[i].x, y: middleValue - stdDev * stdDevMultiplier });
                    } else {
                        // Should not happen if middle band calculation is correct, but handle defensively
                        upper.push({ x: data[i].x, y: null });
                        lower.push({ x: data[i].x, y: null });
                    }
                }
                // Ensure the middle band returned has the same structure
                return { upper, middle, lower };
            }

            // --- Data Processing ---

            /**
             * Parses Kraken OHLC response into ApexCharts OHLC format.
             * Kraken format: [time, open, high, low, close, vwap, volume, count]
             * ApexCharts format: { x: timestamp_ms, y: [open, high, low, close] }
             */
             function formatOHLCDataForInternal(krakenDataArray) {
                 if (!Array.isArray(krakenDataArray)) return [];
                 return krakenDataArray.map(item => ({
                     x: item[0] * 1000, // Kraken timestamp is in seconds, convert to ms
                     y: [
                         parseFloat(item[1]), // open
                         parseFloat(item[2]), // high
                         parseFloat(item[3]), // low
                         parseFloat(item[4])  // close
                     ]
                 })).sort((a, b) => a.x - b.x); // Ensure data is sorted by time
            }


            /** Extracts close price for Area series */
             function deriveAreaChartData(ohlcData) {
                 return ohlcData.map(d => ({
                     x: d.x,
                     y: d.y[3] // Close price
                 }));
            }

            // --- Chart Logic ---

            function initChart() {
                const options = {
                    chart: {
                        type: 'line', // Base type
                        height: '100%', // Fill container
                        background: '#000000',
                        animations: {
                            enabled: true,
                            easing: 'linear',
                            dynamicAnimation: {
                                speed: 1000
                            }
                        },
                        toolbar: { show: false },
                        zoom: { enabled: false }, // Disable zoom for TV display
                         foreColor: '#e0e0e0' // Default text color for chart elements
                    },
                    series: [
                         {
                             name: 'Price',
                             type: 'area',
                             data: [],
                             color: '#f3b429' // Bitcoin Orange
                         },
                         {
                             name: 'SMA 10',
                             type: 'line',
                             data: [],
                             color: '#FFFF00' // Yellow
                         },
                         {
                             name: 'SMA 20',
                             type: 'line',
                             data: [],
                             color: '#FF0000' // Red
                         },
                         {
                             name: 'BB Upper',
                             type: 'line',
                             data: [],
                             color: '#6c757d' // Gray
                         },
                          {
                             name: 'BB Middle', // Same as SMA(20)
                             type: 'line',
                             data: [],
                             color: '#6c757d', // Gray
                         },
                         {
                             name: 'BB Lower',
                             type: 'line',
                             data: [],
                             color: '#6c757d' // Gray
                         }
                     ],
                    theme: {
                        mode: 'dark'
                    },
                    xaxis: {
                        type: 'datetime',
                        labels: {
                            style: { colors: '#999', fontSize: '11px' },
                             format: 'HH:mm', // Show time only
                             datetimeUTC: false // Use local time from browser
                        },
                         axisBorder: { show: false },
                         axisTicks: { show: false },
                         tooltip: { enabled: false } // Disable x-axis tooltip part
                    },
                    yaxis: {
                         opposite: true, // Y-axis on the right
                         labels: {
                            style: { colors: '#999', fontSize: '11px' },
                            formatter: (value) => formatCurrency(value)
                         },
                         axisBorder: { show: false },
                         tooltip: { // Customize y-axis tooltip if needed
                            enabled: true,
                            formatter: (value) => formatCurrency(value)
                         }
                    },
                    grid: {
                        borderColor: '#444', // Darker gray grid lines
                        strokeDashArray: 3,
                        yaxis: { lines: { show: true } },
                        xaxis: { lines: { show: false } } // Hide vertical grid lines
                    },
                     tooltip: {
                        enabled: true,
                        shared: true, // Show all series values on hover
                        intersect: false,
                        theme: 'dark',
                        x: {
                             format: 'dd MMM HH:mm' // Tooltip date format
                        },
                        y: {
                            formatter: (value, { seriesIndex, w }) => {
                                // Custom format based on series index
                                const seriesName = w.globals.seriesNames[seriesIndex];
                                if (value === null || value === undefined) return "N/A";

                                if (seriesName === 'Price' || seriesName.includes('BB') || seriesName.includes('SMA')) {
                                     return formatCurrency(value);
                                }
                                return formatNumber(value); // Default formatting
                             }
                        },
                        marker: { show: false } // Hide dots in tooltip
                    },
                    stroke: { // Common stroke settings
                        width: [2, 1.5, 1.5, 1, 1, 1], // Widths for Area, SMA10, SMA20, BBs
                        curve: 'smooth',
                        dashArray: [0, 0, 0, 4, 4, 4] // Dashes for BBs
                    },
                     fill: { // For the Area chart
                         type: 'gradient',
                         gradient: {
                            shadeIntensity: 1,
                            opacityFrom: 0.4, // Slightly more opaque gradient start
                            opacityTo: 0.05, // Fade out more
                            stops: [0, 95, 100] // Gradient stops
                         }
                    },
                    markers: { // Hide markers on lines
                         size: 0,
                         hover: { size: 0 }
                    },
                     legend: {
                        show: false // <-- Legend explicitly hidden here
                    },
                };

                chart = new ApexCharts(chartContainer, options);
                chart.render().then(() => {
                     console.log("Chart rendered. Performing initial OHLC fetch.");
                     fetchAndUpdateOHLC(true); // Perform initial full fetch
                }).catch(err => {
                     console.error("ApexCharts render error:", err);
                     showChartStatus('Error rendering chart', 'error', 0);
                 });
            }

             /** Update chart series data */
             function updateChartSeries() {
                if (!chart || !fullChartDataOHLC || fullChartDataOHLC.length === 0) {
                    console.log("Chart or data not ready for update.");
                    return;
                }
                // console.log(`Updating chart with ${fullChartDataOHLC.length} data points.`);

                 try {
                    const areaData = deriveAreaChartData(fullChartDataOHLC);
                    const sma10Data = calculateSMA(fullChartDataOHLC, 10);
                    const sma20Data = calculateSMA(fullChartDataOHLC, 20);
                    const bbData = calculateBollingerBands(fullChartDataOHLC, 20, 2); // Period 20, 2 Std Dev

                    // Check if calculations returned valid data
                     if (!areaData.length || !sma10Data.length || !sma20Data.length || !bbData.upper.length) {
                         console.warn("Indicator calculation resulted in empty data. Skipping chart update.");
                         return;
                     }

                     chart.updateSeries([
                        { data: areaData },
                        { data: sma10Data },
                        { data: sma20Data },
                        { data: bbData.upper },
                         { data: bbData.middle }, // Update BB Middle (SMA20)
                        { data: bbData.lower }
                     ]).catch(err => {
                          console.error("Error updating chart series:", err);
                          showChartStatus('Error updating chart data', 'error');
                     });

                 } catch (error) {
                      console.error("Error calculating indicators or preparing data:", error);
                      showChartStatus('Error processing chart data', 'error');
                 }
            }

            // --- Data Fetching Functions ---

             async function fetchKrakenAPI(endpoint, params = '') {
                 const url = `${KRAKEN_API_BASE}/${endpoint}${params ? `?${params}` : ''}`;
                 // console.log("Fetching:", url); // Log URL for debugging
                 try {
                     const response = await fetch(url);
                     if (!response.ok) {
                         throw new Error(`HTTP error! status: ${response.status}`);
                     }
                     const data = await response.json();
                     // Kraken API specific error handling
                     if (data.error && data.error.length > 0) {
                         throw new Error(`Kraken API Error: ${data.error.join(', ')}`);
                     }
                     if (!data.result) {
                          throw new Error('Kraken API Error: Missing result field.');
                     }
                     return data.result;
                 } catch (error) {
                     console.error(`Error fetching ${endpoint}:`, error);
                     throw error; // Re-throw to be caught by caller
                 }
            }

            async function fetchAndUpdatePrice() {
                 try {
                     const result = await fetchKrakenAPI('Ticker', `pair=${BTC_PAIR}`);
                     // Kraken nests the pair data, e.g., result['XXBTZUSD']
                     const pairKey = Object.keys(result)[0];
                     if (!pairKey || !result[pairKey]) {
                         throw new Error('Invalid ticker data structure from Kraken');
                     }
                     const tickerData = result[pairKey];

                     // c = last trade closed array(<price>, <lot volume>)
                     // p = 24 hour volume weighted average price array(<today>, <last 24 hours>)
                     // h = high array(<today>, <last 24 hours>)
                     // l = low array(<today>, <last 24 hours>)
                     const currentPrice = parseFloat(tickerData.c[0]);
                     const high24h = parseFloat(tickerData.h[1]);
                     const low24h = parseFloat(tickerData.l[1]);
                     // Calculate 24h change: (lastPrice - openPrice) / openPrice * 100
                     // Kraken provides 'o' = today's opening price. Use this for daily change.
                     const openPrice = parseFloat(tickerData.o);
                     const change24h = openPrice ? ((currentPrice - openPrice) / openPrice) * 100 : 0;


                     priceEl.textContent = formatCurrency(currentPrice);
                     priceEl.classList.remove('loading', 'error');

                     change24hEl.textContent = `${formatNumber(change24h, 2, 2)}%`;
                     change24hEl.className = change24h > 0 ? 'positive' : change24h < 0 ? 'negative' : 'neutral';

                     high24hEl.textContent = formatCurrency(high24h);
                     low24hEl.textContent = formatCurrency(low24h);

                 } catch (error) {
                     console.error("Error updating price:", error);
                     priceEl.textContent = 'Error';
                     priceEl.classList.add('error');
                     priceEl.classList.remove('loading');
                     change24hEl.textContent = '---%';
                     change24hEl.className = 'neutral';
                     high24hEl.textContent = '---';
                     low24hEl.textContent = '---';
                 }
            }

            async function fetchAndUpdateOHLC(isInitialFetch = false) {
                 showChartStatus('Updating chart data...', 'info', 5000); // Show loading status
                 let params = `pair=${BTC_PAIR}&interval=${CHART_INTERVAL}`;
                 if (!isInitialFetch && lastOHLCTimestamp) {
                     params += `&since=${lastOHLCTimestamp}`;
                 }

                 try {
                     const result = await fetchKrakenAPI('OHLC', params);
                     const pairKey = Object.keys(result).find(key => key !== 'last'); // Find the pair key (e.g., XXBTZUSD)
                     if (!pairKey || !result[pairKey]) {
                          throw new Error('Invalid OHLC data structure from Kraken');
                     }
                     const newOHLCData = formatOHLCDataForInternal(result[pairKey]);
                     lastOHLCTimestamp = result.last; // Update the 'since' timestamp for the next fetch

                     // Merge data
                     if (isInitialFetch || !fullChartDataOHLC.length) {
                         fullChartDataOHLC = newOHLCData;
                         console.log(`Initial OHLC fetch complete. ${fullChartDataOHLC.length} points.`);
                     } else if (newOHLCData.length > 0) {
                          // Filter out potential duplicates and merge sorted arrays
                          const lastExistingTimestamp = fullChartDataOHLC[fullChartDataOHLC.length - 1]?.x;
                          const uniqueNewData = newOHLCData.filter(d => d.x > lastExistingTimestamp);
                          fullChartDataOHLC = [...fullChartDataOHLC, ...uniqueNewData];
                          console.log(`Incremental OHLC fetch complete. Added ${uniqueNewData.length} new points. Total: ${fullChartDataOHLC.length}`);
                     } else {
                         console.log("Incremental OHLC fetch returned no new data points.");
                     }

                    // Limit data points to avoid performance issues (e.g., last 2000 points)
                    const maxDataPoints = 2000;
                    if (fullChartDataOHLC.length > maxDataPoints) {
                        fullChartDataOHLC = fullChartDataOHLC.slice(-maxDataPoints);
                         // console.log(`Trimmed OHLC data to last ${maxDataPoints} points.`);
                    }

                    if (fullChartDataOHLC.length > 0) {
                         updateChartSeries();
                         showChartStatus('Chart updated', 'success', 2000);
                    } else {
                         showChartStatus('No chart data available', 'info', 5000);
                    }


                 } catch (error) {
                     console.error("Error updating OHLC data:", error);
                     showChartStatus(`Error fetching chart data: ${error.message}`, 'error', 10000);
                 }
            }

            async function fetchAndUpdateCryptoTicker() {
                 try {
                     const result = await fetchKrakenAPI('Ticker', `pair=${OTHER_CRYPTO_PAIRS}`);
                     let tickerHTML = '';

                     // Map Kraken's internal names (like XETHZUSD) to common names (ETH/USDT)
                     const pairMap = {
                         'ETHUSDT': 'ETH/USDT',
                         'SOLUSDT': 'SOL/USDT',
                         'ADAUSDT': 'ADA/USDT',
                         'XRPUSDT': 'XRP/USDT',
                     };
                     const krakenKeys = Object.keys(result);

                     OTHER_CRYPTO_PAIRS.split(',').forEach(pair => {
                         const krakenPairKey = krakenKeys.find(k => k.includes(pair.replace('USDT', ''))); // Simplistic match

                         if (krakenPairKey && result[krakenPairKey]) {
                             const price = parseFloat(result[krakenPairKey].c[0]);
                             const displayName = pairMap[pair] || pair;
                             const decimals = price < 1 ? 4 : price < 100 ? 3 : 2;
                             tickerHTML += `<span><span class="ticker-pair">${displayName}:</span> <span class="ticker-price">$${formatNumber(price, decimals, decimals)}</span></span>`;
                         } else {
                             tickerHTML += `<span><span class="ticker-pair">${pairMap[pair] || pair}:</span> <span class="error">Error</span></span>`;
                             console.warn(`Could not find data for ${pair} in Kraken response. Keys: ${krakenKeys.join(', ')}`);
                         }
                     });

                     // Duplicate the content to ensure smooth looping scroll
                     cryptoTickerContentEl.innerHTML = tickerHTML + tickerHTML;

                 } catch (error) {
                      console.error("Error updating crypto ticker:", error);
                      cryptoTickerContentEl.innerHTML = `<span><span class="error">Error loading crypto prices...</span></span>`;
                 }
            }

            // --- Initialization ---
            function initializeDashboard() {
                console.log("Initializing Dashboard...");

                // Clear existing intervals if any (good practice on script reload)
                clearInterval(priceIntervalId);
                clearInterval(chartIntervalId);
                clearInterval(tickerIntervalId);

                // Initial data fetches
                fetchAndUpdatePrice();
                fetchAndUpdateCryptoTicker();
                // initChart will call fetchAndUpdateOHLC after render

                 // Initialize Chart (this will trigger initial OHLC fetch)
                initChart();


                // Set up intervals for periodic updates
                priceIntervalId = setInterval(fetchAndUpdatePrice, PRICE_UPDATE_INTERVAL);
                chartIntervalId = setInterval(() => fetchAndUpdateOHLC(false), CHART_UPDATE_INTERVAL); // Incremental updates
                tickerIntervalId = setInterval(fetchAndUpdateCryptoTicker, TICKER_UPDATE_INTERVAL);

                console.log("Dashboard Initialized. Intervals set.");
            }

            initializeDashboard();

        });
    </script>
</body>
</html>
